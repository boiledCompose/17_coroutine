## 작업

`launch()` 함수로 코루틴을 실행하면 `Job`인스턴스가 반환된다.

`Job`은 코루틴에 대한 핸들링 또는 참조를 보유하고 코루틴의 수명 주기를 관리할 수 있다.

```kotlin
val job = launch { ... }
```

작업의 수명 주기는 일반적으로 4가지가 있다:
1. **시작:**

작업은 코루틴의 수명 주기 또는 지속 시간을 제어하는 데 사용할 수 있다. (예: 작업이 필요하지 않은 경우 코루틴을 취소)
```kotlin
job.cancel()
```

작업을 사용해 코루틴의 활성, 취소, 완료 등의 상태를 확인할 수 있다. 또한 코루틴 간의 상위-하위 관계를 추적한다.

### 작업 계층 구조

코루틴이 다른 코루틴을 실행할 때 새 코루틴에서 반환되는 작업을 **원래 상위 작업의 하위 요소(작업)** 라고 한다. 

이 상위-하위 관계는 하위 요소와 상위 요소 및 동일한 상위 요소에 속한 다른 하위 요소의 특정 동작을 지정하므로 중요하다.

- 상위 작업이 취소되면 그 하위 작업도 취소된다.
- 하위 작업이 취소돼도 그 상위 작업은 취소되지 않는다.
- 하위 작업이 예외와 함께 실패하면 이 예외로 상위 항목이 취소된다. ***(오류 상향 전파)***

<br>

## CoroutineScope

코루틴이 일반적으로 `CoroutineScope`로 실행된다. 이렇게 하면 코루틴이 관리되지 않아 손실되는 일이 없고 리소스 낭비를 방지한다.
`launch()`와 `async()`는 `CoroutineScope`의 확장 함수이다.

`CoroutineScope`는 수명 주기와 연결되어 범위 내의 코루틴이 유지되는 기간에 경계를 설정한다.

- 범위(Scope)가 취소되면 작업이 취소되고, 취소가 하위 요소들에게 전파된다.
- 범위 내의 하위 작업이 예외와 함께 실패하면 상위 작업에 예외가 전파되면서 다른 하위 작업들과 함께 취소된다.
- 상위 작업이 예외와 함께 취소되면 호출자에 예외가 다시 발생한다.

<br>

## CoroutineContext

`CoroutineContext`는 코루틴이 실행될 `Context`에 관한 정보를 제공한다.

`CoroutineContext`는 본질적으로 각 요소에 고유한 키가 있는 요소를 저장하는 맵이며, 필수 필드는 아니지만 다음과 같은 항목을 컨텍스트에 포함한다:

- 이름: 코루틴 고유 식별자
- 작업: 코루틴 수명 주기 제어용
- 디스패처: 스레드에 작업 분배
- 예외 핸들러: 코루틴 코드에서 발생하는 예외 처리

`Context`의 각 요소는 `+` 연산자로 추가될 수 있다.
```kotlin
val coroutineContext:CoroutineContext = Job() + Dispatchers.Main + exceptionHandler
```

코루틴 내에서 새로운 코루틴을 실행하는 경우 하위 코루틴은 상위 코루틴의 `CoroutineContext`를 상속받는다.
직접 지정하고 싶은 경우, 따로 정의하거나 `launch()`와 `async()`에 인수를 전달하면 된다.
```kotlin
scope.launch(Dispatcher.Default)
```

## Dispatcher

코루틴은 디스패처를 사용하여 실행에 사용할 스레드를 결정한다.

스레딩 동작과 관련하여 알아야 하는 두 가지 용어는 **차단**과 **비차단**이다. 차단의 경우, 작업이 완료될 때까지 호출 스레드를 생성하지 않고 다른 작업을 실행할 수 없다. 반대로 비차단의 경우 특정 조건이 충족될 때까지 호출 스레드를 생성하므로 그동안 다른 작업을 수행할 수 있다. 이러한 비차단 작업을 비동기 함수로 하는 것이다.

Android 앱의 경우 매우 빠르게 실행되는 작업만 기본 스레드에서 차단 코드로 호출해야 한다. 새 이벤트가 발생하면 즉시 작업이 실행될 수 있도록 기본 스레드를 차단 해제 상태로 유지하는 것이 좋은 앱의 목표이다. 이 기본 스레드는 **액티비티의 UI 스레드**이며 UI 그리기 및 관련 이벤트를 담당한다.

기본 스레드가 장기 실행 작업 블록을 실행하게 되면 화면이 자주 업데이트되지 않고 버벅거림, 갑작스런 앱 중단, 느린 반응 등을 보이게 된다. 따라서 장기 실행 작업을 기본 스레드 외부로 이동하여 다른 스레드에서 처리해야 한다. 앱은 기본 스레드부터 시작하지만, 추가 작업을 실행할 여러 스레드를 만들 수 있다. 이러한 스레드들을 **작업자 스레드**라고 부른다.

코틀린에서 제공하는 몇 가지 기본 디스패처가 있다:

1. **Dispatcher.Main:** 기본 스레드에서 코루틴을 실행할 때 쓰인다. 주로 UI 업데이트 및 상호작용을 처리하고 빠른 작업을 실행하는 데 사용한다.
2. **Dispatcher.IO:** 기본 스레드 외부에서 디스크 또는 네트워크 I/O를 실행하도록 최적화돼 있다.
3. **Dispatcher.Default:** 컨텍스트에 디스패처가 지정되지 않은 상태에서 launch() 및 async()를 호출할 때 사용되는 기본 디스패처이다. 주로 계산이 많은 작업을 기본 스레드 외부에서 실행하기 위해 사용된다.
     ```
     fun main() {
        runBlocking {
            launch {
                withContext(Dispatchers.Default) {
                    delay(1000)
                    println("10 results found.")
                }
            }
            println("Loading...")
        }
     }
     ```
    > `withContext()`도 정지 함수이므로 디스패처 전환이 가능하다.

